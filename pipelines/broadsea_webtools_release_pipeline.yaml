# Pipeline to deploy the broadsea-webtools docker container
trigger: none

parameters:
# For artifact retrieval
- name: sourcePipelineArtifactProjectName
  displayName: Source Pipeline Artifact Project Name (e.g. use myproject for https://dev.azure.com/<myorg>/<myproject>/)
  type: string
  default: OHDSIonAzure
- name: sourcePipelineArtifactPipelineName
  displayName: Source Pipeline Artifact Pipeline Name (E.g Broadsea Build)
  type: string
  default: Broadsea Build

# web Api Parameters
- name: buildArtifactNameWebApi
  type: string
  default: webApiScript
  displayName: Build Artifact for WebApi Script
  values:
  - webApiScript
- name: scriptFileNameWebApi
  type: string
  default: Web_Api_Refresh.sql
  displayName: Web API Script file name (e.g. Web_Api_Refresh.sql)

# Docker Settings
- name: dockerBuildImageName
  type: string
  default: broadsea-webtools
  displayName: Image Name (e.g. broadsea-webtools) to pull from ACR.  Defaults to empty.
- name: dockerBuildImageTag
  type: string
  default: latest
  displayName: Image Tag (e.g. latest) to pull from ACR.  Defaults to empty.

variables:
- template: variables.yaml
- name: acrImageTag
  value: "${{ variables.containerRegistry }}.azurecr.io/${{ parameters.dockerBuildImageName }}:${{ parameters.dockerBuildImageTag }}"

pool: 'Azure Pipelines'

stages:
- stage: Deploy_to_Dev
  displayName: Deploy image to App Service
  jobs:
    - job:
      steps:
        - task: AzureCLI@2
          displayName: Configure App Service with Latest Docker Image
          inputs:
            azureSubscription: ${{ variables.serviceConnection }}
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              # Deploy latest image by setting App Service container configuration to latest image
              echo "az webapp config container set --docker-custom-image-name ${{ lower(variables.acrImageTag) }} --name ${{ variables.appSvcName }} --resource-group ${{ variables.appSvcRg}}"
              az webapp config container set --docker-custom-image-name ${{ lower(variables.acrImageTag) }} --name ${{ variables.appSvcName }} --resource-group ${{ variables.appSvcRg }}

        # install sqlcmd
        - template: templates/install_sqlcmd.yml

        - task: DownloadPipelineArtifact@2
          inputs:
            source: 'specific'
            project: '${{ parameters.sourcePipelineArtifactProjectName }}'
            pipeline: '${{ parameters.sourcePipelineArtifactPipelineName }}'
            runVersion: 'latest'
            runBranch: 'refs/heads/$(Build.SourceBranchName)'
            path: $(Build.SourcesDirectory)/artifacts

        # TODO: Do we need to make sure the [webapi].[source] / [webapi].[source_daimon] tables are empty?
        - script: |
            echo "APP SERVICE HOST: ${{ variables.webapiSources }}/sources"

            response=$(curl -s -H "Accept: application/json" -o response.txt -w "%{http_code}" "${{ variables.webapiSources }}/sources")

            echo "Entering iteration now..."

            for i in {1..50}; do
              if [[ $i == 50 ]]; then
                echo "WebAPI has not responded. Session timeout."
                exit 1
              else
                # Curl Response
                echo "Checking if container has started yet..."
                response=$(curl -s -H "Accept: application/json" -o response.txt -w "%{http_code}" "${{ variables.webapiSources }}/sources")
                cat response.txt
              fi

              if [[ $response == "200" ]]; then
                  echo ""
                  echo "Container has started. Exiting verification cycle..."
                  echo "Got response status code: $response"
                  break
              fi

              # Wait 30 seconds
              echo "WebAPI needs more time. Waiting 30 seconds."
              sleep 30
            done
          displayName: 'Confirm Web API is Available'

        - template: templates/run_sqlcmd_script.yml
          parameters:
            serviceConnection: ${{ variables.serviceConnection }}
            sqlServerName: ${{ variables.sqlServerName }}
            sqlServerDbName: ${{ variables.sqlServerDbName }}
            sourceFolderPath: 'artifacts/${{ parameters.buildArtifactNameWebApi }}'
            scriptFileName: ${{ parameters.scriptFileNameWebApi }}
            sqlcmdCommandLineParameters: '-v SQL_SERVER_NAME="${{ variables.sqlServerName }}" -v SQL_DATABASE_NAME="${{ variables.sqlServerDbName }}"'

        - script: |
              # curl response again
              response=$(curl "${{ variables.webapiSources }}/sources")
              echo "Curl Response ${{ variables.webapiSources }}/sources for : $response"

              # refresh sources endpoint once more
              response=$(curl "${{ variables.webapiSources }}/refresh")
              echo "Curl Response for ${{ variables.webapiSources }}/refresh: $response"

              echo "fin"
          displayName: 'Refresh Web Api'
